{"version":3,"file":"static/js/528.c5879ffe.chunk.js","mappings":"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","sources":["modelos/Casilla.js","utilidades/auxiliares.js","modelos/Tablero.js","modelos/Caballo.js","modelos/AlgoritmoBacktracking.js","utilidades/backtracking-worker.js"],"sourcesContent":["/**\r\n * @fileoverview Clase que representa una casilla individual del tablero.\r\n */\r\n\r\n/**\r\n * Representa una casilla del tablero con su posición, estado de visitada y vecinos.\r\n * @class\r\n */\r\nexport class Casilla {\r\n  /**\r\n   * Crea una nueva instancia de Casilla.\r\n   * @param {number} fila - La fila donde se encuentra la casilla (0-indexada).\r\n   * @param {number} columna - La columna donde se encuentra la casilla (0-indexada).\r\n   */\r\n  constructor(fila, columna) {\r\n    /** @type {number} La fila de la casilla en el tablero. */\r\n    this.fila = fila;\r\n    \r\n    /** @type {number} La columna de la casilla en el tablero. */\r\n    this.columna = columna;\r\n    \r\n    /** @type {boolean} Indica si la casilla ha sido visitada por el caballo. */\r\n    this.visitada = false;\r\n    \r\n    /** \r\n     * @type {Array<{casilla: Casilla, intentado: boolean}>} \r\n     * Lista de objetos que representan las casillas vecinas accesibles \r\n     * junto con un indicador de si ya fueron intentadas desde esta casilla.\r\n     */\r\n      this.vecinos = [];\r\n\r\n  }\r\n\r\n  /**\r\n   * Agrega una casilla vecina a la lista de vecinos accesibles.\r\n   * @param {Casilla} casilla - La casilla vecina que se va a agregar.\r\n   */\r\n  agregarVecino(casilla) {\r\n    this.vecinos.push({casilla, intentado: false});\r\n  }\r\n}\r\n\r\nexport default Casilla;","// Validaciones y funciones de apoyo\r\n\r\n/**\r\n * Extrae el tamaño numérico de un string de formato \"NxN\"\r\n * @param {string} tamanoString - String en formato \"8x8\", \"6x6\", etc.\r\n * @returns {number} El valor N del tablero\r\n */\r\nexport const extraerTamanoTablero = (tamanoString) => {\r\n  return parseInt(tamanoString.toString().split('x')[0], 10);\r\n};\r\n\r\n/**\r\n * Valida si un número está dentro del rango válido [0, max)\r\n * @param {number} valor - El valor a validar\r\n * @param {number} max - El límite superior (exclusivo)\r\n * @returns {boolean} true si está en rango válido\r\n */\r\nconst esCoordenadaValida = (valor, max) => {\r\n  return !isNaN(valor) && valor >= 0 && valor < max;\r\n};\r\n\r\n/**\r\n * Valida si un par de coordenadas está dentro de los límites del tablero\r\n * @param {number} fila - La coordenada de fila\r\n * @param {number} columna - La coordenada de columna  \r\n * @param {number} tamanoTablero - El tamaño del tablero (N para NxN)\r\n * @returns {boolean} true si ambas coordenadas son válidas\r\n */\r\nexport const sonCoordenadasValidasEnTablero = (fila, columna, tamanoTablero) => {\r\n  return esCoordenadaValida(fila, tamanoTablero) && \r\n         esCoordenadaValida(columna, tamanoTablero);\r\n};\r\n\r\n/**\r\n * Convierte un valor a entero y valida que sea un número válido\r\n * @param {any} valor - El valor a convertir\r\n * @returns {number|null} El valor convertido o null si no es válido\r\n */\r\nconst convertirAEnteroValido = (valor) => {\r\n  const entero = parseInt(valor, 10);\r\n  return isNaN(entero) ? null : entero;\r\n};\r\n\r\n/**\r\n * Valida y convierte coordenadas de entrada del usuario\r\n * @param {string|number} fila - Valor de fila a validar\r\n * @param {string|number} columna - Valor de columna a validar\r\n * @param {string} tamanoString - String de tamaño en formato \"NxN\"\r\n * @returns {object} Objeto con {validas: boolean, fila: number, columna: number, n: number}\r\n */\r\nexport const validarCoordenadas = (fila, columna, tamanoString) => {\r\n  const n = extraerTamanoTablero(tamanoString);\r\n  const filaNum = convertirAEnteroValido(fila);\r\n  const columnaNum = convertirAEnteroValido(columna);\r\n  \r\n  const validas = filaNum !== null && \r\n                  columnaNum !== null && \r\n                  sonCoordenadasValidasEnTablero(filaNum, columnaNum, n);\r\n  \r\n  return {\r\n    validas,\r\n    fila: filaNum,\r\n    columna: columnaNum,\r\n    n\r\n  };\r\n};\r\n\r\n","/**\r\n * @fileoverview Clase que representa el tablero nxn con todas sus casillas.\r\n */\r\n\r\nimport { Casilla } from './Casilla.js';\r\nimport { sonCoordenadasValidasEnTablero } from '../utilidades/auxiliares.js';\r\n\r\n/**\r\n * Representa un tablero de ajedrez con casillas interconectadas según\r\n * los movimientos válidos del caballo.\r\n * @class\r\n */\r\nexport class Tablero {\r\n  /**\r\n   * Crea una nueva instancia del Tablero.\r\n   * @param {number} n - El tamaño del tablero (n x n casillas).\r\n   */\r\n  constructor(n) {\r\n    /** @type {number} El tamaño del tablero (número de filas y columnas). */\r\n    this.n = n;\r\n    \r\n    /** @type {Array<Array<Casilla>>} Matriz de casillas. */\r\n    this.casillas = [];\r\n    \r\n    this._crearCasillas();\r\n    this._asignarVecinos();\r\n  }\r\n\r\n  /**\r\n   * Crea la matriz de casillas del tablero.\r\n   * @private\r\n   */\r\n  _crearCasillas() {\r\n    for (let fila = 0; fila < this.n; fila++) {\r\n      this.casillas[fila] = [];\r\n      for (let columna = 0; columna < this.n; columna++) {\r\n        this.casillas[fila][columna] = new Casilla(fila, columna);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Asigna los vecinos accesibles a cada casilla según los movimientos del caballo.\r\n   * @private\r\n   */\r\n  _asignarVecinos() {\r\n    \r\n    const movimientosFila = [2, 1, -1, -2, -2, -1, 1, 2];\r\n    const movimientosColumna = [1, 2, 2, 1, -1, -2, -2, -1];\r\n\r\n    for (let fila = 0; fila < this.n; fila++) {\r\n      for (let columna = 0; columna < this.n; columna++) {\r\n        for (let i = 0; i < 8; i++) {\r\n          const filaCasilla = fila + movimientosFila[i];\r\n          const columnaCasilla = columna + movimientosColumna[i];\r\n          \r\n          // Verificar que la nueva posición esté dentro del tablero\r\n          if (sonCoordenadasValidasEnTablero(filaCasilla, columnaCasilla, this.n)) {\r\n            this.casillas[fila][columna].agregarVecino(\r\n              this.casillas[filaCasilla][columnaCasilla]\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Obtiene la casilla en la posición especificada.\r\n   * @param {number} fila - La fila de la casill.\r\n   * @param {number} columna - La columna de la casilla.\r\n   * @returns {Casilla} La casilla en la posición especificada.\r\n   * @throws {Error} Si las coordenadas están fuera del tablero.\r\n   */\r\n  obtenerCasilla(fila, columna) {\r\n    if (!sonCoordenadasValidasEnTablero(fila, columna, this.n)) {\r\n      throw new Error(`Posición fuera del tablero: (${fila}, ${columna})`);\r\n    }\r\n    return this.casillas[fila][columna];\r\n  }\r\n}\r\n\r\nexport default Tablero;","/**\r\n * @fileoverview Clase que representa el caballo en el tablero y maneja su movimiento.\r\n */\r\n\r\n/**\r\n * Representa el caballo con su posición actual, historial de movimientos\r\n * y estadísticas del recorrido.\r\n * @class\r\n */\r\nexport class Caballo {\r\n  /**\r\n   * Crea una nueva instancia del Caballo.\r\n   * @param {Casilla} casillaInicial - Casilla donde comienza el recorrido.\r\n   * @param {number} totalCasillas - Total de casillas del tablero \r\n   */\r\n  constructor(casillaInicial, totalCasillas) {\r\n    /** @type {Casilla} La casilla donde se encuentra actualmente el caballo. */\r\n    this.posicionActual = casillaInicial;\r\n\r\n    /** @type {Casilla} La casilla donde inicia el caballo. Se guarda en caso de hacer el recorrido cerrado*/\r\n    this.casillaInicial = casillaInicial;\r\n    \r\n    /** @type {Array<Casilla>} Historial completo de movimientos (incluye retrocesos). */\r\n    this.historial = [casillaInicial];\r\n    \r\n    /** @type {Array<Casilla>} Camino actual hacia la solución (sin retrocesos). */\r\n    this.solucion = [casillaInicial];\r\n    \r\n    /** @type {number} Contador de movimientos realizados. */\r\n    this.movimientos = 0;\r\n    \r\n    /** @type {number} Contador de retrocesos realizados. */\r\n    this.retrocesos = 0;\r\n    \r\n    /** @type {number} Número de casillas visitadas actualmente. */\r\n    this.casillasVisitadas = 1;\r\n    \r\n    /** @type {number} Total de casillas en el tablero. */\r\n    this.totalCasillas = totalCasillas;\r\n    \r\n    casillaInicial.visitada = true;\r\n  }\r\n\r\n  /**\r\n   * Mueve el caballo a una nueva casilla y actualiza el estado.\r\n   * Marca el vecino como intentado desde la casilla actual.\r\n   * @param {Casilla} nuevaCasilla - La casilla destino del movimiento.\r\n   */\r\n  avanzarA(nuevaCasilla) {\r\n    // marcar que desde la casilla actual se intentó este vecino\r\n    for (let vecino of this.posicionActual.vecinos) {\r\n      if (vecino.casilla === nuevaCasilla) {\r\n        vecino.intentado = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.posicionActual = nuevaCasilla;\r\n    \r\n    \r\n    if (this.historial.length < 100_000) {\r\n      this.historial.push(nuevaCasilla);\r\n    }\r\n    \r\n    this.solucion.push(nuevaCasilla); \r\n    this.movimientos++;\r\n    nuevaCasilla.visitada = true;\r\n    this.casillasVisitadas++;\r\n    \r\n  }\r\n\r\n  /**\r\n   * Retrocede el caballo a la casilla anterior en el historial.\r\n   * Desmarca la casilla actual como visitada y actualiza las estadísticas.\r\n   */\r\n  retroceder() {\r\n    if (this.solucion.length > 1) {\r\n      const ultima = this.solucion.pop(); \r\n      ultima.visitada = false;\r\n\r\n      const anterior = this.solucion[this.solucion.length - 1];\r\n\r\n      \r\n      if (this.historial.length < 100_000) {\r\n        this.historial.push(anterior);\r\n      }\r\n\r\n      // resetear el intento en el vecino\r\n      for (let vecino of anterior.vecinos) {\r\n        if (vecino.casilla === ultima) {\r\n          vecino.intentado = false;\r\n          break;\r\n        }\r\n      }\r\n\r\n      this.posicionActual = anterior;\r\n      this.retrocesos++;\r\n      this.casillasVisitadas--;\r\n      \r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verifica si el caballo ha completado el recorrido visitando todas las casillas.\r\n   * @returns {boolean} True si se han visitado todas las casillas, false en caso contrario.\r\n   */\r\n  recorridoCompleto() {\r\n    return this.casillasVisitadas === this.totalCasillas;\r\n  }\r\n\r\n  /**\r\n   * Reinicia el estado del caballo a la casilla inicial.\r\n   * Limpia el historial y restablece todos los contadores.\r\n   * @param {Casilla} casillaInicial - La casilla donde reiniciar el caballo.\r\n   */\r\n  reiniciar(casillaInicial) {\r\n    // Desmarcar todas las casillas visitadas\r\n    for (let i = 0; i < this.solucion.length; i++) {\r\n      this.solucion[i].visitada = false;\r\n    }\r\n    \r\n    this.historial = [casillaInicial];    \r\n    this.solucion = [casillaInicial];     \r\n    this.posicionActual = casillaInicial;\r\n    this.movimientos = 0;\r\n    this.retrocesos = 0;\r\n    this.casillasVisitadas = 1;\r\n    casillaInicial.visitada = true;\r\n  }\r\n}\r\n\r\nexport default Caballo;\r\n","/**\r\n * @fileoverview Algoritmo de backtracking para resolver el recorrido del caballo.\r\n * Permite calcular tanto recorridos abiertos como cerrados.\r\n */\r\n\r\n\r\n/**\r\n * Intenta resolver el recorrido completo del caballo usando backtracking.\r\n *\r\n * @param {!Caballo} caballo Instancia del caballo en el tablero.\r\n * @param {boolean=} cerrado True si se busca un recorrido cerrado (por defecto false).\r\n * @return {boolean} True si se encontró un recorrido válido, false en caso contrario.\r\n */\r\nexport function resolverRecorrido(caballo, cerrado = false) {\r\n  if (caballo.recorridoCompleto()) {\r\n    if (cerrado) {\r\n      return caballo.posicionActual.vecinos.some(\r\n          (vecino) => vecino.casilla === caballo.casillaInicial);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  \r\n  const vecinosDisponibles = caballo.posicionActual.vecinos\r\n      .filter((vecino) => !vecino.casilla.visitada && !vecino.intentado)\r\n      .map((vecino) => vecino.casilla);\r\n\r\n  if (vecinosDisponibles.length === 0) {\r\n    return false;\r\n  }\r\n\r\n \r\n  vecinosDisponibles.sort(() => Math.random() - 0.5);\r\n\r\n  \r\n  for (const casilla of vecinosDisponibles) {\r\n    caballo.avanzarA(casilla);\r\n\r\n    if (resolverRecorrido(caballo, cerrado)) {\r\n      return true;\r\n    }\r\n\r\n    caballo.retroceder();\r\n  }\r\n\r\n  return false;\r\n}\r\n","/* eslint-disable no-restricted-globals */\r\n\r\n/**\r\n * @fileoverview Web Worker para ejecutar el algoritmo de backtracking\r\n * del caballo, enviando actualizaciones de progreso y resultados.\r\n */\r\n\r\nimport { Tablero } from '../modelos/Tablero.js';\r\nimport { Caballo } from '../modelos/Caballo.js';\r\nimport { resolverRecorrido } from '../modelos/AlgoritmoBacktracking.js';\r\n\r\nfunction enviarMensaje(tipo, datos) {\r\n  self.postMessage({ tipo, datos });\r\n}\r\n\r\nfunction formatearTiempo(ms) {\r\n  return ms < 1000 ? `${Math.round(ms)}ms` : `${(ms / 1000).toFixed(2)}s`;\r\n}\r\n\r\n/** Limita el historial para no saturar la memoria. */\r\nfunction limitarHistorial(historial, limite) {\r\n  if (historial.length > limite) {\r\n    return {\r\n      historial: historial.slice(0, limite),\r\n      historialMuestreado: true,\r\n      historialOriginalLength: historial.length,\r\n    };\r\n  }\r\n  return {\r\n    historial,\r\n    historialMuestreado: false,\r\n  };\r\n}\r\n\r\n/**\r\n * Ejecuta el algoritmo de backtracking, enviando progreso periódico.\r\n *\r\n * @param {!Caballo} caballo Instancia del caballo.\r\n * @param {boolean} recorridoCerrado True si se busca recorrido cerrado.\r\n * @param {number} tiempoInicio Marca de tiempo inicial.\r\n * @return {boolean} True si se encontró solución.\r\n */\r\nfunction ejecutarConProgreso(caballo, recorridoCerrado, tiempoInicio) {\r\n  let contadorIteraciones = 0;\r\n\r\n  enviarMensaje('progreso', { tiempoEjecucion: '0ms' });\r\n\r\n  const originalAvanzarA = caballo.avanzarA.bind(caballo);\r\n  caballo.avanzarA = (casilla) => {\r\n    contadorIteraciones++;\r\n\r\n    if (contadorIteraciones % 500 === 0) {\r\n      const tiempoTranscurrido = performance.now() - tiempoInicio;\r\n      enviarMensaje('progreso', {\r\n        tiempoEjecucion: formatearTiempo(tiempoTranscurrido),\r\n        iteraciones: contadorIteraciones,\r\n        movimientos: caballo.movimientos,\r\n        retrocesos: caballo.retrocesos,\r\n      });\r\n    }\r\n    return originalAvanzarA(casilla);\r\n  };\r\n\r\n  const resultado = resolverRecorrido(caballo, recorridoCerrado);\r\n  caballo.avanzarA = originalAvanzarA; \r\n  return resultado;\r\n}\r\n\r\nself.onmessage = (event) => {\r\n  const { tipo, datos } = event.data;\r\n  if (tipo !== 'iniciar') return;\r\n\r\n  const { tamano, recorridoCerrado, filaInicial, columnaInicial } = datos;\r\n\r\n  try {\r\n    const tablero = new Tablero(tamano);\r\n    const casillaInicial = tablero.obtenerCasilla(filaInicial, columnaInicial);\r\n    const caballo = new Caballo(casillaInicial, tamano * tamano);\r\n\r\n    const tiempoInicio = performance.now();\r\n    const solucionEncontrada = ejecutarConProgreso(caballo, recorridoCerrado, tiempoInicio);\r\n    const duracion = performance.now() - tiempoInicio;\r\n\r\n    const datosResultado = {\r\n      solucionEncontrada,\r\n      tiempoEjecucion: formatearTiempo(duracion),\r\n      movimientos: caballo.movimientos,\r\n      retrocesos: caballo.retrocesos,\r\n    };\r\n\r\n    if (solucionEncontrada) {\r\n      Object.assign(datosResultado, limitarHistorial(caballo.historial, 30000));\r\n      datosResultado.solucion = caballo.solucion;\r\n    } else {\r\n      Object.assign(datosResultado, limitarHistorial(caballo.historial, 3000));\r\n      datosResultado.solucion = [];\r\n      if (datosResultado.historialMuestreado) {\r\n        datosResultado.mensaje =\r\n          `No se encontró solución. Mostrando primeros 3,000 de ${caballo.historial.length.toLocaleString()} movimientos explorados.`;\r\n      } else {\r\n        datosResultado.mensaje = 'No se encontró solución.';\r\n      }\r\n    }\r\n\r\n    enviarMensaje('completado', datosResultado);\r\n  } catch (error) {\r\n    enviarMensaje('error', { mensaje: error.message, stack: error.stack });\r\n  }\r\n};\r\n"],"names":["Casilla","constructor","fila","columna","this","visitada","vecinos","agregarVecino","casilla","push","intentado","esCoordenadaValida","valor","max","isNaN","sonCoordenadasValidasEnTablero","tamanoTablero","Tablero","n","casillas","_crearCasillas","_asignarVecinos","movimientosFila","movimientosColumna","i","filaCasilla","columnaCasilla","obtenerCasilla","Error","concat","Caballo","casillaInicial","totalCasillas","posicionActual","historial","solucion","movimientos","retrocesos","casillasVisitadas","avanzarA","nuevaCasilla","vecino","length","retroceder","ultima","pop","anterior","recorridoCompleto","reiniciar","resolverRecorrido","caballo","cerrado","arguments","undefined","some","vecinosDisponibles","filter","map","sort","Math","random","enviarMensaje","tipo","datos","self","postMessage","formatearTiempo","ms","round","toFixed","limitarHistorial","limite","slice","historialMuestreado","historialOriginalLength","ejecutarConProgreso","recorridoCerrado","tiempoInicio","contadorIteraciones","tiempoEjecucion","originalAvanzarA","bind","performance","now","iteraciones","resultado","onmessage","event","data","tamano","filaInicial","columnaInicial","solucionEncontrada","datosResultado","Object","assign","mensaje","toLocaleString","error","message","stack"],"sourceRoot":""}